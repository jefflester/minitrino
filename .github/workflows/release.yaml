---
name: Publish Release on Merge to Master

on:
  pull_request:
    branches:
      - master
    types:
      - closed
  workflow_dispatch:
    inputs:
      version:
        description: "Version to release (e.g., 3.0.3)"
        required: true
        type: string

env:
  # Normalize version: use input for workflow_dispatch, head_ref for PR triggers
  RELEASE_VERSION: ${{ inputs.version || github.head_ref }}

jobs:
  # ============================================================================
  # STAGE 1: Publish to PyPI
  # ============================================================================
  pypi-publish:
    if: github.event.pull_request.merged == true || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-22.04
    steps:
      - name: Check out code
        uses: actions/checkout@v6
        with:
          ref: master

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: pip install build twine

      - name: Build and check distribution
        run: |
          python -m build
          twine check dist/*

      - name: Publish distribution to PyPI
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.PYPI_TOKEN }}
        run: |
          PYPI_URL="https://pypi.org/pypi/minitrino/${RELEASE_VERSION}/json"
          RESPONSE=$(curl --silent "${PYPI_URL}")
          if echo "${RESPONSE}" | grep -q "\"${RELEASE_VERSION}\""; then
            echo "Package version ${RELEASE_VERSION} already exists on PyPI."
            echo "Skipping upload."
          else
            echo "Uploading package version ${RELEASE_VERSION} to PyPI..."
            twine upload dist/*
          fi

      - name: Wait for PyPI availability
        run: |
          echo "Waiting for package to be available on PyPI..."
          MAX_ATTEMPTS=10
          ATTEMPT=1
          until pip download minitrino==${RELEASE_VERSION} --no-deps -d /tmp; do
            if [ $ATTEMPT -ge $MAX_ATTEMPTS ]; then
              echo "Package not available on PyPI after ${ATTEMPT} attempts."
              exit 1
            fi
            echo "Attempt ${ATTEMPT} failed. Retrying in 30 seconds..."
            ATTEMPT=$((ATTEMPT+1))
            sleep 30
          done
          echo "Package ${RELEASE_VERSION} is available on PyPI"

  # ============================================================================
  # STAGE 2: Create GitHub Release (not marked as latest yet)
  # ============================================================================
  create-release:
    needs: pypi-publish
    runs-on: ubuntu-22.04
    steps:
      - name: Check out code
        uses: actions/checkout@v6
        with:
          ref: master

      - name: Create release (not latest)
        env:
          GITHUB_TOKEN: ${{ secrets.MINITRINO_TOKEN }}
        run: |
          VERSION="${RELEASE_VERSION}"
          RELEASE_NOTES="./release-notes/${VERSION}.md"

          if [ ! -f "${RELEASE_NOTES}" ]; then
            echo "Release notes file not found at ${RELEASE_NOTES}. Exiting..."
            exit 1
          fi

          DESCRIPTION=$(cat "${RELEASE_NOTES}")

          echo "Checking existing releases..."
          if gh release list | grep -q -e "${VERSION}"; then
            echo "Release ${VERSION} found. Deleting..."
            gh release delete "${VERSION}" -y --cleanup-tag || true
          fi

          echo "Creating release ${VERSION} (not marked as latest yet)..."
          gh release create "${VERSION}" \
            --title "${VERSION}" \
            --notes "${DESCRIPTION}" \
            --target master \
            --latest=false

          echo "Release ${VERSION} created successfully!"

  # ============================================================================
  # STAGE 3: Smoke Test (Gate for Release)
  # ============================================================================
  smoke-test:
    needs: create-release
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-22.04, macos-15]
    runs-on: ${{ matrix.os }}
    steps:
      # NOTE: We intentionally do NOT checkout the repo here.
      # This simulates an end-user installing from PyPI without access
      # to the source repository, which catches bugs like lib_dir
      # falling back to src/lib in the repo tree.

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: "3.11"

      - name: Install minitrino from PyPI
        env:
          VERSION: ${{ env.RELEASE_VERSION }}
        run: |
          echo "Installing minitrino version ${VERSION} from PyPI..."
          pip install minitrino==${VERSION} --no-cache-dir
          echo "Successfully installed minitrino ${VERSION}"

      - name: Verify CLI is accessible
        run: |
          minitrino --version
          minitrino --help

      - name: Test config command (no library required)
        run: |
          # The config command should work without a library installed
          echo "Testing 'minitrino config --reset' without library..."
          export TEXT_EDITOR=true
          echo "y" | minitrino -v config --reset || {
            echo "ERROR: 'minitrino config --reset' failed without library"
            exit 1
          }
          if [ ! -f ~/.minitrino/minitrino.cfg ]; then
            echo "ERROR: Config file not created"
            exit 1
          fi
          echo "Config command succeeded"

      - name: Test lib-install command
        env:
          VERSION: ${{ env.RELEASE_VERSION }}
        run: |
          echo "Testing 'minitrino lib-install' for version ${VERSION}..."
          echo "y" | minitrino -v lib-install --version "${VERSION}" || {
            echo "ERROR: 'minitrino lib-install' failed"
            exit 1
          }
          if [ ! -d ~/.minitrino/lib ]; then
            echo "ERROR: Library directory not created"
            exit 1
          fi
          INSTALLED_VERSION=$(cat ~/.minitrino/lib/version)
          echo "Installed library version: ${INSTALLED_VERSION}"
          if [ "${INSTALLED_VERSION}" != "${VERSION}" ]; then
            echo "ERROR: Version mismatch. Expected ${VERSION}, got ${INSTALLED_VERSION}"
            exit 1
          fi
          echo "Library installation succeeded"

      - name: Test modules command
        run: |
          echo "Testing 'minitrino modules' command..."
          minitrino modules || {
            echo "ERROR: 'minitrino modules' failed"
            exit 1
          }
          echo "Modules command succeeded"

      - name: Set up Docker (macOS)
        if: runner.os == 'macOS'
        run: |
          brew install coreutils docker colima
          colima start --cpu 2 --memory 4

      - name: Test provision command (30s timeout)
        run: |
          echo "Testing 'minitrino provision' with 30s timeout..."

          # Use gtimeout on macOS, timeout on Linux
          if command -v gtimeout &> /dev/null; then
            TIMEOUT_CMD="gtimeout"
          else
            TIMEOUT_CMD="timeout"
          fi

          set +e
          $TIMEOUT_CMD 30 minitrino -v provision 2>&1 | tee provision.log
          EXIT_CODE=$?
          set -e

          # timeout returns 124 when it kills the process
          if [ $EXIT_CODE -eq 124 ]; then
            echo "Provision ran for 30s as expected (killed by timeout)"
          elif [ $EXIT_CODE -eq 0 ]; then
            echo "Provision completed successfully"
          else
            echo "ERROR: Provision failed with exit code ${EXIT_CODE}"
            cat provision.log
            exit 1
          fi
          echo "Provision smoke test passed"

      - name: Cleanup
        if: always()
        run: |
          minitrino down 2>/dev/null || true
          minitrino remove --volumes 2>/dev/null || true

  # ============================================================================
  # STAGE 4: Mark Release as Latest (only if smoke test passes)
  # ============================================================================
  mark-latest:
    needs: smoke-test
    runs-on: ubuntu-22.04
    steps:
      - name: Mark release as latest
        env:
          GITHUB_TOKEN: ${{ secrets.MINITRINO_TOKEN }}
        run: |
          VERSION="${RELEASE_VERSION}"
          echo "Marking release ${VERSION} as latest..."
          gh release edit "${VERSION}" \
            --repo "${{ github.repository }}" \
            --latest
          echo "Release ${VERSION} marked as latest!"
